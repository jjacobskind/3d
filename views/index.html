<!doctype html>
	<head>
		<link rel='stylesheet' href='stylesheets/style.css'>
	</head>
	<body>
		<script src='javascripts/three.min.js'></script>
		<script src='javascripts/OrbitControls.js'></script>
		<script src='javascripts/Mirror.js'></script>
		<script src='javascripts/WaterShader.js'></script>
		<script type='text/javascript'>

	
			var camera, scene, renderer, controls, light, water;

			init();
			animate();

			function init() {

				var tile_depth = 5;

				var map = document.createElement( 'div' );
				map.style.position = 'absolute';
				map.style.width = '100%';
				document.body.appendChild( map );

				renderer = new THREE.WebGLRenderer({antialias:true});
				renderer.setClearColor( 0xA1CEED );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 0, 200, 300 );

				controls = new THREE.OrbitControls( camera );
				controls.addEventListener( 'change', render );
				// controls.autoRotate=true;
				controls.noPan = true;
				controls.maxPolarAngle = Math.PI/2.5;

				scene.add( new THREE.AmbientLight( 0x222222 ) );

				light = new THREE.PointLight( 0xffffff );
				light.position.copy( camera.position );
				scene.add( light );

				var material = new THREE.MeshLambertMaterial( { color: 0xffffff, wireframe: false } );


				//Begin Water Rendering

				var waterNormals = new THREE.ImageUtils.loadTexture( 'images/waternormals.jpg' );
				waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping; 

				water = new THREE.Water( renderer, camera, scene, {
					waterNormals: waterNormals,
					alpha: 	0.8,
					sunDirection: light.position.clone().normalize(),
					sunColor: 0xffffff,
					waterColor: 0x3D50E0,
					distortionScale: 50.0,
				} );

				var mirrorMesh = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( 10000, 10000 ),
					water.material
				);

				mirrorMesh.position.set(0, tile_depth*-1, 0);

				mirrorMesh.rotation.x = - Math.PI * 0.5;
				scene.add( mirrorMesh );


				// Begin Board Rendering

				var pts = [], numPts = 6;
				var l = 30;

				for ( var i = 0; i < numPts * 2; i+=2 ) {

					var a = i / numPts * Math.PI;

					pts.push( new THREE.Vector2 ( Math.cos( a ) * l, Math.sin( a ) * l ) );

				}

				var shape = new THREE.Shape( pts );

				var material2 = new THREE.MeshLambertMaterial( { color: 0xff8000, wireframe: false } );

				var materials = [ material, material2 ];

				var extrudeSettings = {
					amount			: tile_depth,
					steps			: 1,
					material		: 1,
					extrudeMaterial : 0,
					bevelEnabled	: true,
					bevelThickness  : 1,
					bevelSize       : 4,
					bevelSegments   : 1,
				};

				var circlePts = [];
				var numCirclePts = 32

				for(i=0;i<numCirclePts*2;i++){
					var a = i/numCirclePts * Math.PI;
					circlePts.push(new THREE.Vector2(Math.cos(a)*l/4, Math.sin(a)*l/4));
				}

				chip_geometry = new THREE.ExtrudeGeometry(new THREE.Shape(circlePts), {amount:1,
																				bevelEnabled:false
																				});

				geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
				var outer_middle_distance = Math.sqrt(Math.pow(l*4,2) - Math.pow(0.5*l*4, 2));
				var obj=drawTile(0,0);
				var spaces=[obj.tile];
				var num_chips=[obj.num_chip];
				for ( i = 0; i < numPts*2; i++ ) {
					if(i%2===0){
						for(var j=4;j>=2;j-=2) {
							obj = drawTile(i, l*j);
							spaces.push(obj.tile);
							num_chips.push(obj.num_chip);
						}
					} else {
						obj = drawTile(i, outer_middle_distance);
						spaces.push(obj.tile);
						num_chips.push(obj.num_chip);
					}

				}

				function drawTile(i, dist) {
					var tile = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) );
					var a = i / numPts * Math.PI;
					tile.position.set( Math.sin(a)*dist, 0, Math.cos(a)*dist );
					tile.rotation.set(Math.PI/2, 0, 0);
					scene.add( tile );

					var num_chip = new THREE.Mesh(chip_geometry, new THREE.MeshFaceMaterial(materials));
					num_chip.rotation.set(Math.PI/2, 0, 0);
					num_chip.position.set( Math.sin(a)*dist, 2, Math.cos(a)*dist );
					scene.add(num_chip);
					return {tile: tile, num_chip:num_chip};
				};

				function drawSettlement(x, z, color) {
					var pts = [];
					pts.push(new THREE.Vector2(-5, 0));
					pts.push(new THREE.Vector2(5, 0));
					pts.push(new THREE.Vector2(5, 7));
					pts.push(new THREE.Vector2(8, 7));
					pts.push(new THREE.Vector2(0, 13));
					pts.push(new THREE.Vector2(-8, 7));
					pts.push(new THREE.Vector2(-5, 7));
					pts.push(new THREE.Vector2(-5, 0));

					settlement_geometry = new THREE.ExtrudeGeometry(new THREE.Shape(pts), {amount:15,
																				bevelEnabled:false
																				});

					var material = new THREE.MeshLambertMaterial( { color: colorConversion(color), wireframe: false } );

					var settlement = new THREE.Mesh(settlement_geometry, material);
					settlement.position.set( x, 0, z );
					return settlement;
				};

				function drawCity(x,z, color){
					var pts = [];
					pts.push(new THREE.Vector2(-10, 0));
					pts.push(new THREE.Vector2(7, 0));
					pts.push(new THREE.Vector2(7, 9));
					pts.push(new THREE.Vector2(0, 9));
					pts.push(new THREE.Vector2(0, 15));
					pts.push(new THREE.Vector2(-5, 20));
					pts.push(new THREE.Vector2(-10, 15));
					pts.push(new THREE.Vector2(-10, 0));

					settlement_geometry = new THREE.ExtrudeGeometry(new THREE.Shape(pts), {amount:15,
																				bevelEnabled:false
																				});

					var material = new THREE.MeshLambertMaterial( { color: colorConversion(color), wireframe: false } );

					var settlement = new THREE.Mesh(settlement_geometry, material);
					settlement.position.set( x, 0, z );
					return settlement;
				};

				scene.add(drawSettlement(30, 0, "blue"));
				scene.add(drawCity(-30,0, "red"));
			};


			function colorConversion(color_string){
				switch(color_string){
					case "red":
						return 0xff0000;
					case "blue":
						return 0x0000ff;
					case "white":
						return 0xffffff;
					case "orange":
						return 0xf28100;
				}
			};


			function animate() {

				requestAnimationFrame( animate );

				controls.update();


			}

			function render(){
				light.position.copy(camera.position);

				water.material.uniforms.time.value += 1.0 / 60.0;
				water.render();

				renderer.render( scene, camera );
			}

		</script>
	</body>
</html>