<!doctype html>
	<head>
		<link rel='stylesheet' href='stylesheets/style.css'>
	</head>
	<body>
		<script src='javascripts/three.min.js'></script>
		<script src='javascripts/OrbitControls.js'></script>
		<script src='javascripts/Mirror.js'></script>
		<script src='javascripts/WaterShader.js'></script>
		<script type='text/javascript'>

	
			var camera, scene, renderer, controls, light, water;

			init();
			animate();

			function init() {

				var tile_depth = 5;

				var map = document.createElement( 'div' );
				map.style.position = 'absolute';
				map.style.width = '100%';
				document.body.appendChild( map );

				renderer = new THREE.WebGLRenderer({antialias:true});
				renderer.setClearColor( 0xA1CEED );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				renderer.domElement.addEventListener('click', function(event){

					var vector = new THREE.Vector3();

					vector.set(
					    ( event.clientX / window.innerWidth ) * 2 - 1,
					    - ( event.clientY / window.innerHeight ) * 2 + 1,
					    0.5 );

					vector.unproject( camera );

					var dir = vector.sub( camera.position ).normalize();

					var distance = - camera.position.y / dir.y;

					var pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
					scene.add(drawCity(pos.x, pos.z, "red"));
				});

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 0, 200, 300 );

				controls = new THREE.OrbitControls( camera );
				controls.addEventListener( 'change', render );
				// controls.autoRotate=true;
				controls.noPan = true;
				controls.maxPolarAngle = Math.PI/2.5;

				scene.add( new THREE.AmbientLight( 0x222222 ) );

				light = new THREE.PointLight( 0xffffff );
				light.position.copy( camera.position );
				scene.add( light );

				var material = new THREE.MeshLambertMaterial( { color: 0xffffff, wireframe: false } );


				//Begin Water Rendering

				var waterNormals = new THREE.ImageUtils.loadTexture( 'images/waternormals.jpg' );
				waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping; 

				water = new THREE.Water( renderer, camera, scene, {
					waterNormals: waterNormals,
					alpha: 	0.8,
					sunDirection: light.position.clone().normalize(),
					sunColor: 0xffffff,
					waterColor: 0x3D50E0,
					distortionScale: 50.0,
				} );

				var mirrorMesh = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( 10000, 10000 ),
					water.material
				);

				mirrorMesh.position.set(0, tile_depth*-1, 0);

				mirrorMesh.rotation.x = - Math.PI * 0.5;
				scene.add( mirrorMesh );


				// Begin Board Rendering

				var pts = [], numPts = 6;
				var l = 30;

				for ( var i = 0; i < numPts * 2; i+=2 ) {

					var a = i / numPts * Math.PI;

					pts.push( new THREE.Vector2 ( Math.cos( a ) * l, Math.sin( a ) * l ) );

				}

				var shape = new THREE.Shape( pts );

				var material2 = new THREE.MeshLambertMaterial( { color: 0xff8000, wireframe: false } );

				var materials = [ material, material2 ];

				var extrudeSettings = {
					amount			: tile_depth,
					steps			: 1,
					material		: 1,
					extrudeMaterial : 0,
					bevelEnabled	: true,
					bevelThickness  : 1,
					bevelSize       : 4,
					bevelSegments   : 1,
				};

				var circlePts = [];
				var numCirclePts = 32

				for(i=0;i<numCirclePts*2;i++){
					var a = i/numCirclePts * Math.PI;
					circlePts.push(new THREE.Vector2(Math.cos(a)*l/4, Math.sin(a)*l/4));
				}

				chip_geometry = new THREE.ExtrudeGeometry(new THREE.Shape(circlePts), {amount:1,
																				bevelEnabled:false
																				});

			   var resources = [0xFFB13D, 0xFFB13D, 0xFFB13D, 0xFFB13D, 0x996600, 0x996600, 0x996600, 0x996600, 0xE0E0E0, 0xE0E0E0, 0xE0E0E0, 0xE0E0E0, 0x3D3D3D, 0x3D3D3D, 0x3D3D3D, 0xFF0000, 0xFF0000, 0xFF0000, 0xFFFFCC];

			   var shuffleFunction = function(array) {
			       for (var i = array.length - 1; i > 0; i--) {
			           var j = Math.floor(Math.random() * (i + 1));
			           var temp = array[i];
			           array[i] = array[j];
			           array[j] = temp;
			       }
			       return array;
			   };
			   resources = shuffleFunction(resources);

				geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
				var outer_middle_distance = Math.sqrt(Math.pow(l*4,2) - Math.pow(0.5*l*4, 2));
				var obj=drawTile(0,0, 0);
				var spaces=[obj.tile];
				var num_chips=[obj.num_chip];
				var count =0;
				for ( i = 0; i < numPts*2; i++ ) {
					if(i%2===0){
						for(var j=4;j>=2;j-=2) {
							count++;
							obj = drawTile(count, i, l*j);
							spaces.push(obj.tile);
							num_chips.push(obj.num_chip);
						}
					} else {
						count++;
						obj = drawTile(count, i, outer_middle_distance);
						spaces.push(obj.tile);
						num_chips.push(obj.num_chip);
					}

				}

				// var Board = function() {
				// 	this.spaces = [];
				// 	for(var i=0;i<18;i++) {
				// 		this.spaces.push(new Tile);
				// 	}
				// };

				// var Tile = function() {
				// 	this.tile = this.drawTile.tile;
				// };


				function drawTile(count, i, dist) {
					var colored_material = new THREE.MeshLambertMaterial( { color: resources.pop(), wireframe: false } );
					var materialshere = [material, colored_material];

					var tile = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materialshere ) );
					var a = i / numPts * Math.PI;
					tile.position.set( Math.sin(a)*dist, 0, Math.cos(a)*dist );
					tile.rotation.set(Math.PI/2, 0, 0);
					scene.add( tile );


					var num_chip = new THREE.Mesh(chip_geometry, new THREE.MeshFaceMaterial(materials));
					num_chip.rotation.set(Math.PI/2, 0, 0);
					num_chip.position.set( Math.sin(a)*dist, 2, Math.cos(a)*dist );
					scene.add(num_chip);
					return {tile: tile, num_chip:num_chip};
				};

				function drawSettlement(x, z, color) {
					var pts = [];
					pts.push(new THREE.Vector2(-5, 0));
					pts.push(new THREE.Vector2(5, 0));
					pts.push(new THREE.Vector2(5, 7));
					pts.push(new THREE.Vector2(8, 7));
					pts.push(new THREE.Vector2(0, 13));
					pts.push(new THREE.Vector2(-8, 7));
					pts.push(new THREE.Vector2(-5, 7));
					pts.push(new THREE.Vector2(-5, 0));

					settlement_geometry = new THREE.ExtrudeGeometry(new THREE.Shape(pts), {amount:15,
																				bevelEnabled:false
																				});

					var material = new THREE.MeshLambertMaterial( { color: colorConversion(color), wireframe: false } );

					var settlement = new THREE.Mesh(settlement_geometry, material);
					settlement.position.set( x, 0, z );
					return settlement;
				};

				function drawCity(x,z, color){
					var pts = [];
					pts.push(new THREE.Vector2(-10, 0));
					pts.push(new THREE.Vector2(7, 0));
					pts.push(new THREE.Vector2(7, 9));
					pts.push(new THREE.Vector2(0, 9));
					pts.push(new THREE.Vector2(0, 15));
					pts.push(new THREE.Vector2(-5, 20));
					pts.push(new THREE.Vector2(-10, 15));
					pts.push(new THREE.Vector2(-10, 0));

					settlement_geometry = new THREE.ExtrudeGeometry(new THREE.Shape(pts), {amount:15,
																				bevelEnabled:false
																				});

					var material = new THREE.MeshLambertMaterial( { color: colorConversion(color), wireframe: false } );

					var settlement = new THREE.Mesh(settlement_geometry, material);
					settlement.position.set( x, 0, z );
					return settlement;
				};

				(function drawRobber(){
					var points = [];
					var neck_width;
					for ( var i = 0; i < 30; i++ ) {
						if(i<3){
							points.push(new THREE.Vector3( l/5, 0, i ) );
						}
						else if (i>=3 && i<=4){
							points.push(new THREE.Vector3( l/5 - (i-2), 0, i ) );
						}
						else if (i>=5 && i<=20){
							points.push(new THREE.Vector3( l/5 + Math.sin((i-5)/10*Math.PI), 0, i*1.2 ) );
							neck_width = l/5 + Math.sin((i-5)/10*Math.PI);
						}
						else if (i>=21 && i<30){
							points.push(new THREE.Vector3( l/5 + Math.cos((i-21)/10*Math.PI), 0, i*1.2 ) );
						}
					}

					// for(i=0)
					var geometry = new THREE.LatheGeometry( points);
					var material = new THREE.MeshLambertMaterial( { color: 0x111111 } );
					var lathe = new THREE.Mesh( geometry, material );
					lathe.rotation.set(Math.PI,Math.PI/2,0);
					lathe.position.set(0,20,0);
					scene.add( lathe );
				})();

				scene.add(drawSettlement(30, 0, "blue"));
				scene.add(drawCity(-30,0, "red"));
			};


			function colorConversion(color_string){
				switch(color_string){
					case "red":
						return 0xff0000;
					case "blue":
						return 0x0000ff;
					case "white":
						return 0xffffff;
					case "orange":
						return 0xf28100;
				}
			};


			function animate() {

				requestAnimationFrame( animate );

				controls.update();


			}

			function render(){
				light.position.copy(camera.position);

				water.material.uniforms.time.value += 1.0 / 60.0;
				water.render();

				renderer.render( scene, camera );
			}

			(function allotResources(){

			})();


		</script>
	</body>
</html>