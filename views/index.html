<!doctype html>
	<head>
		<link rel='stylesheet' href='stylesheets/style.css'>
	</head>
	<body>
		<script src='javascripts/three.min.js'></script>
		<script src='javascripts/OrbitControls.js'></script>
		<script src='javascripts/Mirror.js'></script>
		<script src='javascripts/WaterShader.js'></script>
		<script type='text/javascript'>

	
			var camera, scene, renderer, controls, light, water;

			init();
			animate();

			function init() {

				var tile_depth = 5;

				var map = document.createElement( 'div' );
				map.style.position = 'absolute';
				map.style.width = '100%';
				document.body.appendChild( map );

				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0xA1CEED );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 0, 200, 300 );

				controls = new THREE.OrbitControls( camera );
				controls.addEventListener( 'change', render );
				// controls.autoRotate=true;
				controls.maxPolarAngle = Math.PI/2.5;

				scene.add( new THREE.AmbientLight( 0x222222 ) );

				light = new THREE.PointLight( 0xffffff );
				light.position.copy( camera.position );
				scene.add( light );

				var material = new THREE.MeshLambertMaterial( { color: 0xffffff, wireframe: false } );


				//Begin Water Rendering

				var waterNormals = new THREE.ImageUtils.loadTexture( 'images/waternormals.jpg' );
				waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping; 

				water = new THREE.Water( renderer, camera, scene, {
					waterNormals: waterNormals,
					alpha: 	0.8,
					sunDirection: light.position.clone().normalize(),
					sunColor: 0xffffff,
					waterColor: 0x3D50E0,
					distortionScale: 50.0,
				} );

				var mirrorMesh = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( 10000, 10000 ),
					water.material
				);

				mirrorMesh.position.set(0, tile_depth*-1, 0);

				mirrorMesh.rotation.x = - Math.PI * 0.5;
				scene.add( mirrorMesh );


				// Begin Board Rendering

				var pts = [], numPts = 6;
				var l = 30;

				for ( var i = 0; i < numPts * 2; i+=2 ) {

					var a = i / numPts * Math.PI;

					pts.push( new THREE.Vector2 ( Math.cos( a ) * l, Math.sin( a ) * l ) );

				}

				var shape = new THREE.Shape( pts );

				var material2 = new THREE.MeshLambertMaterial( { color: 0xff8000, wireframe: false } );

				var materials = [ material, material2 ];

				var extrudeSettings = {
					amount			: tile_depth,
					steps			: 1,
					material		: 1,
					extrudeMaterial : 0,
					bevelEnabled	: true,
					bevelThickness  : 1,
					bevelSize       : 4,
					bevelSegments   : 1,
				};

				geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
				var outer_middle_distance = Math.sqrt(Math.pow(l*4,2) - Math.pow(0.5*l*4, 2));
				var spaces = [new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) )];
				spaces[0].position.set(0, 0, 0);
				spaces[0].rotation.set(Math.PI/2, 0, 0);
				scene.add( spaces[0] );
				for ( i = 0; i < numPts*2; i++ ) {
					if(i%2===0){
						for(var j=4;j>=2;j-=2) {
							spaces.push(new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) ));
							var last=spaces.length-1;
							a = i / numPts * Math.PI;
							spaces[last].position.set( Math.sin(a)*l*j, 0, Math.cos(a)*l*j );
							spaces[last].rotation.set(Math.PI/2, 0, 0);
							scene.add( spaces[last] );
						}
					} else {
						spaces.push(new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) ));
						var last=spaces.length-1;
						a = i / numPts * Math.PI;
						spaces[last].position.set( Math.sin(a)*outer_middle_distance, 0, Math.cos(a)*outer_middle_distance );
						spaces[last].rotation.set(Math.PI/2, 0, 0);
						scene.add( spaces[last] );
					}

				}

			}

			function animate() {

				requestAnimationFrame( animate );

				controls.update();


			}

			function render(){
				light.position.copy(camera.position);

				water.material.uniforms.time.value += 1.0 / 60.0;
				water.render();

				renderer.render( scene, camera );
			}

		</script>
	</body>
</html>