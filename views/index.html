<!doctype html>
	<head>
		<link rel='stylesheet' href='stylesheets/style.css'>
	</head>
	<body>
		<script src='javascripts/three.min.js'></script>
		<script src='javascripts/OrbitControls.js'></script>
		<script src='javascripts/Mirror.js'></script>
		<script src='javascripts/WaterShader.js'></script>
		<script src='javascripts/settlers.js'></script>
		<script type='text/javascript'>

	
			var camera, scene, renderer, controls, light, water;

			init();
			animate();

			function init() {


				var map = document.createElement( 'div' );
				map.style.position = 'absolute';
				map.style.width = '100%';
				document.body.appendChild( map );

				renderer = new THREE.WebGLRenderer({antialias:true});
				renderer.setClearColor( 0xA1CEED );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				renderer.domElement.addEventListener('click', function(event){

					var vector = new THREE.Vector3();

					vector.set(
					    ( event.clientX / window.innerWidth ) * 2 - 1,
					    - ( event.clientY / window.innerHeight ) * 2 + 1,
					    0.5 );

					vector.unproject( camera );

					var dir = vector.sub( camera.position ).normalize();

					var distance = - camera.position.y / dir.y;

					var pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
					scene.add(drawCity(pos.x, pos.z, "red"));
				});

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 0, 200, 300 );

				controls = new THREE.OrbitControls( camera );
				controls.addEventListener( 'change', render );
				// controls.autoRotate=true;
				controls.noPan = true;
				controls.maxPolarAngle = Math.PI/2.5;

				scene.add( new THREE.AmbientLight( 0x222222 ) );

				light = new THREE.PointLight( 0xffffff );
				light.position.copy( camera.position );
				scene.add( light );



				//Begin Water Rendering

				var waterNormals = new THREE.ImageUtils.loadTexture( 'images/waternormals.jpg' );
				waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping; 

				water = new THREE.Water( renderer, camera, scene, {
					waterNormals: waterNormals,
					alpha: 	0.8,
					sunDirection: light.position.clone().normalize(),
					sunColor: 0xffffff,
					waterColor: 0x3D50E0,
					distortionScale: 50.0,
				} );

				var mirrorMesh = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( 10000, 10000 ),
					water.material
				);

				mirrorMesh.position.set(0, tile_depth*-1, 0);

				mirrorMesh.rotation.x = - Math.PI * 0.5;
				scene.add( mirrorMesh );






			   

				

				var a = new Game();

				function drawSettlement(x, z, color) {
					var pts = [];
					pts.push(new THREE.Vector2(-5, 0));
					pts.push(new THREE.Vector2(5, 0));
					pts.push(new THREE.Vector2(5, 7));
					pts.push(new THREE.Vector2(8, 7));
					pts.push(new THREE.Vector2(0, 13));
					pts.push(new THREE.Vector2(-8, 7));
					pts.push(new THREE.Vector2(-5, 7));
					pts.push(new THREE.Vector2(-5, 0));

					settlement_geometry = new THREE.ExtrudeGeometry(new THREE.Shape(pts), {amount:15,
																				bevelEnabled:false
																				});

					var material = new THREE.MeshLambertMaterial( { color: colorConversion(color), wireframe: false } );

					var settlement = new THREE.Mesh(settlement_geometry, material);
					settlement.position.set( x, 0, z );
					return settlement;
				};

				function drawCity(x,z, color){
					var pts = [];
					pts.push(new THREE.Vector2(-10, 0));
					pts.push(new THREE.Vector2(7, 0));
					pts.push(new THREE.Vector2(7, 9));
					pts.push(new THREE.Vector2(0, 9));
					pts.push(new THREE.Vector2(0, 15));
					pts.push(new THREE.Vector2(-5, 20));
					pts.push(new THREE.Vector2(-10, 15));
					pts.push(new THREE.Vector2(-10, 0));

					settlement_geometry = new THREE.ExtrudeGeometry(new THREE.Shape(pts), {amount:15,
																				bevelEnabled:false
																				});

					var material = new THREE.MeshLambertMaterial( { color: colorConversion(color), wireframe: false } );

					var settlement = new THREE.Mesh(settlement_geometry, material);
					settlement.position.set( x, 0, z );
					return settlement;
				};

				(function drawRobber(){
					var points = [];
					var neck_width;
					for ( var i = 0; i < 30; i++ ) {
						if(i<3){
							points.push(new THREE.Vector3( l/5, 0, i ) );
						}
						else if (i>=3 && i<=4){
							points.push(new THREE.Vector3( l/5 - (i-2), 0, i ) );
						}
						else if (i>=5 && i<=20){
							points.push(new THREE.Vector3( l/5 + Math.sin((i-5)/10*Math.PI), 0, i*1.2 ) );
							neck_width = l/5 + Math.sin((i-5)/10*Math.PI);
						}
						else if (i>=21 && i<30){
							points.push(new THREE.Vector3( l/5 + Math.cos((i-21)/10*Math.PI), 0, i*1.2 ) );
						}
					}

					// for(i=0)
					var geometry = new THREE.LatheGeometry( points);
					var material = new THREE.MeshLambertMaterial( { color: 0x111111 } );
					var lathe = new THREE.Mesh( geometry, material );
					lathe.rotation.set(Math.PI,Math.PI/2,0);
					lathe.position.set(0,20,0);
					scene.add( lathe );
				})();

				scene.add(drawSettlement(30, 0, "blue"));
				scene.add(drawCity(-30,0, "red"));
			};


			function colorConversion(color_string){
				switch(color_string){
					case "red":
						return 0xff0000;
					case "blue":
						return 0x0000ff;
					case "white":
						return 0xffffff;
					case "orange":
						return 0xf28100;
				}
			};


			function animate() {

				requestAnimationFrame( animate );

				controls.update();


			}

			function render(){
				light.position.copy(camera.position);

				water.material.uniforms.time.value += 1.0 / 60.0;
				water.render();

				renderer.render( scene, camera );
			}

			(function allotResources(){

			})();


		</script>
	</body>
</html>